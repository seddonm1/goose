// This file is auto-generated by @hey-api/openapi-ts

export type Annotations = {
    audience?: Array<Role> | null;
    priority?: number | null;
    timestamp?: string;
};

export type ConfigKey = {
    default?: string | null;
    name: string;
    required: boolean;
    secret: boolean;
};

export type ConfigKeyQuery = {
    is_secret: boolean;
    key: string;
};

export type ConfigResponse = {
    config: {};
};

export type Content = (TextContent & {
    type: 'text';
}) | (ImageContent & {
    type: 'image';
}) | (EmbeddedResource & {
    type: 'resource';
});

export type ContextLengthExceeded = {
    msg: string;
};

/**
 * Request payload for context management operations
 */
export type ContextManageRequest = {
    /**
     * Operation to perform: "truncation" or "summarize"
     */
    manageAction: string;
    /**
     * Collection of messages to be managed
     */
    messages: Array<Message>;
};

/**
 * Response from context management operations
 */
export type ContextManageResponse = {
    /**
     * Processed messages after the operation
     */
    messages: Array<Message>;
    /**
     * Token counts for each processed message
     */
    tokenCounts: Array<number>;
};

export type CreateScheduleRequest = {
    cron: string;
    execution_mode?: string | null;
    id: string;
    recipe_source: string;
};

export type EmbeddedResource = {
    annotations?: Annotations | null;
    resource: ResourceContents;
};

export type Envs = {
    [key: string]: string;
};

/**
 * Represents the different types of MCP extensions that can be added to the manager
 */
export type ExtensionConfig = {
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    description?: string | null;
    env_keys?: Array<string>;
    envs?: Envs;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'sse';
    uri: string;
} | {
    args: Array<string>;
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    cmd: string;
    description?: string | null;
    env_keys?: Array<string>;
    envs?: Envs;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'stdio';
} | {
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    display_name?: string | null;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'builtin';
} | {
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    description?: string | null;
    env_keys?: Array<string>;
    envs?: Envs;
    /**
     * The name used to identify this extension
     */
    name: string;
    timeout?: number | null;
    type: 'streamable_http';
    uri: string;
} | {
    /**
     * Whether this extension is bundled with Goose
     */
    bundled?: boolean | null;
    /**
     * Instructions for how to use these tools
     */
    instructions?: string | null;
    /**
     * The name used to identify this extension
     */
    name: string;
    /**
     * The tools provided by the frontend
     */
    tools: Array<Tool>;
    type: 'frontend';
};

export type ExtensionEntry = ExtensionConfig & {
    type?: 'ExtensionEntry';
} & {
    enabled: boolean;
};

export type ExtensionQuery = {
    config: ExtensionConfig;
    enabled: boolean;
    name: string;
};

export type ExtensionResponse = {
    extensions: Array<ExtensionEntry>;
};

export type FrontendToolRequest = {
    id: string;
    toolCall: {
        [key: string]: unknown;
    };
};

export type ImageContent = {
    annotations?: Annotations | null;
    data: string;
    mimeType: string;
};

export type InspectJobResponse = {
    processStartTime?: string | null;
    runningDurationSeconds?: number | null;
    sessionId?: string | null;
};

export type KillJobResponse = {
    message: string;
};

export type ListSchedulesResponse = {
    jobs: Array<ScheduledJob>;
};

/**
 * A message to or from an LLM
 */
export type Message = {
    content: Array<MessageContent>;
    created: number;
    role: Role;
};

/**
 * Content passed inside a message, which can be both simple content and tool content
 */
export type MessageContent = (TextContent & {
    type: 'text';
}) | (ImageContent & {
    type: 'image';
}) | (ToolRequest & {
    type: 'toolRequest';
}) | (ToolResponse & {
    type: 'toolResponse';
}) | (ToolConfirmationRequest & {
    type: 'toolConfirmationRequest';
}) | (FrontendToolRequest & {
    type: 'frontendToolRequest';
}) | (ThinkingContent & {
    type: 'thinking';
}) | (RedactedThinkingContent & {
    type: 'redactedThinking';
}) | (ContextLengthExceeded & {
    type: 'contextLengthExceeded';
}) | (SummarizationRequested & {
    type: 'summarizationRequested';
});

/**
 * Information about a model's capabilities
 */
export type ModelInfo = {
    /**
     * The maximum context length this model supports
     */
    context_limit: number;
    /**
     * Currency for the costs (default: "$")
     */
    currency?: string | null;
    /**
     * Cost per token for input (optional)
     */
    input_token_cost?: number | null;
    /**
     * The name of the model
     */
    name: string;
    /**
     * Cost per token for output (optional)
     */
    output_token_cost?: number | null;
};

export type PermissionConfirmationRequest = {
    action: string;
    id: string;
    principal_type?: PrincipalType;
};

/**
 * Enum representing the possible permission levels for a tool.
 */
export type PermissionLevel = 'always_allow' | 'ask_before' | 'never_allow';

export type PrincipalType = 'Extension' | 'Tool';

export type ProviderDetails = {
    is_configured: boolean;
    metadata: ProviderMetadata;
    name: string;
};

/**
 * Metadata about a provider's configuration requirements and capabilities
 */
export type ProviderMetadata = {
    /**
     * Required configuration keys
     */
    config_keys: Array<ConfigKey>;
    /**
     * The default/recommended model for this provider
     */
    default_model: string;
    /**
     * Description of the provider's capabilities
     */
    description: string;
    /**
     * Display name for the provider in UIs
     */
    display_name: string;
    /**
     * A list of currently known models with their capabilities
     * TODO: eventually query the apis directly
     */
    known_models: Array<ModelInfo>;
    /**
     * Link to the docs where models can be found
     */
    model_doc_link: string;
    /**
     * The unique identifier for this provider
     */
    name: string;
};

export type ProvidersResponse = {
    providers: Array<ProviderDetails>;
};

export type RedactedThinkingContent = {
    data: string;
};

export type ResourceContents = {
    mime_type?: string | null;
    text: string;
    uri: string;
} | {
    blob: string;
    mime_type?: string | null;
    uri: string;
};

export type Role = 'user' | 'assistant';

export type RunNowResponse = {
    session_id: string;
};

export type ScheduledJob = {
    cron: string;
    current_session_id?: string | null;
    currently_running?: boolean;
    execution_mode?: string | null;
    id: string;
    last_run?: string | null;
    paused?: boolean;
    process_start_time?: string | null;
    source: string;
};

export type SessionDisplayInfo = {
    accumulatedInputTokens?: number | null;
    accumulatedOutputTokens?: number | null;
    accumulatedTotalTokens?: number | null;
    createdAt: string;
    id: string;
    inputTokens?: number | null;
    messageCount: number;
    name: string;
    outputTokens?: number | null;
    scheduleId?: string | null;
    totalTokens?: number | null;
    workingDir: string;
};

export type SessionHistoryResponse = {
    /**
     * List of messages in the session conversation
     */
    messages: Array<Message>;
    metadata: SessionMetadata;
    /**
     * Unique identifier for the session
     */
    sessionId: string;
};

export type SessionInfo = {
    id: string;
    metadata: SessionMetadata;
    modified: string;
    path: string;
};

export type SessionListResponse = {
    /**
     * List of available session information objects
     */
    sessions: Array<SessionInfo>;
};

/**
 * Metadata for a session, stored as the first line in the session file
 */
export type SessionMetadata = {
    /**
     * The number of input tokens used in the session. Accumulated across all messages.
     */
    accumulated_input_tokens?: number | null;
    /**
     * The number of output tokens used in the session. Accumulated across all messages.
     */
    accumulated_output_tokens?: number | null;
    /**
     * The total number of tokens used in the session. Accumulated across all messages (useful for tracking cost over an entire session).
     */
    accumulated_total_tokens?: number | null;
    /**
     * A short description of the session, typically 3 words or less
     */
    description: string;
    /**
     * The number of input tokens used in the session. Retrieved from the provider's last usage.
     */
    input_tokens?: number | null;
    /**
     * Number of messages in the session
     */
    message_count: number;
    /**
     * The number of output tokens used in the session. Retrieved from the provider's last usage.
     */
    output_tokens?: number | null;
    /**
     * ID of the schedule that triggered this session, if any
     */
    schedule_id?: string | null;
    /**
     * The total number of tokens used in the session. Retrieved from the provider's last usage.
     */
    total_tokens?: number | null;
    /**
     * Working directory for the session
     */
    working_dir: string;
};

export type SessionsQuery = {
    limit?: number;
};

export type SummarizationRequested = {
    msg: string;
};

export type TextContent = {
    annotations?: Annotations | null;
    text: string;
};

export type ThinkingContent = {
    signature: string;
    thinking: string;
};

/**
 * A tool that can be used by a model.
 */
export type Tool = {
    annotations?: ToolAnnotations | null;
    /**
     * A description of what the tool does
     */
    description: string;
    /**
     * A JSON Schema object defining the expected parameters for the tool
     */
    inputSchema: unknown;
    /**
     * The name of the tool
     */
    name: string;
};

/**
 * Additional properties describing a tool to clients.
 *
 * NOTE: all properties in ToolAnnotations are **hints**.
 * They are not guaranteed to provide a faithful description of
 * tool behavior (including descriptive properties like `title`).
 *
 * Clients should never make tool use decisions based on ToolAnnotations
 * received from untrusted servers.
 */
export type ToolAnnotations = {
    /**
     * If true, the tool may perform destructive updates to its environment.
     * If false, the tool performs only additive updates.
     *
     * (This property is meaningful only when `read_only_hint == false`)
     *
     * Default: true
     */
    destructiveHint?: boolean;
    /**
     * If true, calling the tool repeatedly with the same arguments
     * will have no additional effect on its environment.
     *
     * (This property is meaningful only when `read_only_hint == false`)
     *
     * Default: false
     */
    idempotentHint?: boolean;
    /**
     * If true, this tool may interact with an "open world" of external
     * entities. If false, the tool's domain of interaction is closed.
     * For example, the world of a web search tool is open, whereas that
     * of a memory tool is not.
     *
     * Default: true
     */
    openWorldHint?: boolean;
    /**
     * If true, the tool does not modify its environment.
     *
     * Default: false
     */
    readOnlyHint?: boolean;
    /**
     * A human-readable title for the tool.
     */
    title?: string | null;
};

export type ToolConfirmationRequest = {
    arguments: unknown;
    id: string;
    prompt?: string | null;
    toolName: string;
};

/**
 * Information about the tool used for building prompts
 */
export type ToolInfo = {
    description: string;
    name: string;
    parameters: Array<string>;
    permission?: PermissionLevel | null;
};

export type ToolPermission = {
    permission: PermissionLevel;
    tool_name: string;
};

export type ToolRequest = {
    id: string;
    toolCall: {
        [key: string]: unknown;
    };
};

export type ToolResponse = {
    id: string;
    toolResult: {
        [key: string]: unknown;
    };
};

export type ToolResultSchema = {
    data: {
        [key: string]: unknown;
    };
    message?: string | null;
    success: boolean;
};

export type UpdateScheduleRequest = {
    cron: string;
};

export type UpsertConfigQuery = {
    is_secret: boolean;
    key: string;
    value: unknown;
};

export type UpsertPermissionsQuery = {
    tool_permissions: Array<ToolPermission>;
};

export type GetToolsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Optional extension name to filter tools
         */
        extension_name?: string | null;
    };
    url: '/agent/tools';
};

export type GetToolsErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Agent not initialized
     */
    424: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetToolsResponses = {
    /**
     * Tools retrieved successfully
     */
    200: Array<ToolInfo>;
};

export type GetToolsResponse = GetToolsResponses[keyof GetToolsResponses];

export type ReadAllConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config';
};

export type ReadAllConfigResponses = {
    /**
     * All configuration values retrieved successfully
     */
    200: ConfigResponse;
};

export type ReadAllConfigResponse = ReadAllConfigResponses[keyof ReadAllConfigResponses];

export type BackupConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/backup';
};

export type BackupConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type BackupConfigResponses = {
    /**
     * Config file backed up
     */
    200: string;
};

export type BackupConfigResponse = BackupConfigResponses[keyof BackupConfigResponses];

export type GetExtensionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/extensions';
};

export type GetExtensionsErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetExtensionsResponses = {
    /**
     * All extensions retrieved successfully
     */
    200: ExtensionResponse;
};

export type GetExtensionsResponse = GetExtensionsResponses[keyof GetExtensionsResponses];

export type AddExtensionData = {
    body: ExtensionQuery;
    path?: never;
    query?: never;
    url: '/config/extensions';
};

export type AddExtensionErrors = {
    /**
     * Invalid request
     */
    400: unknown;
    /**
     * Could not serialize config.yaml
     */
    422: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type AddExtensionResponses = {
    /**
     * Extension added or updated successfully
     */
    200: string;
};

export type AddExtensionResponse = AddExtensionResponses[keyof AddExtensionResponses];

export type RemoveExtensionData = {
    body?: never;
    path: {
        name: string;
    };
    query?: never;
    url: '/config/extensions/{name}';
};

export type RemoveExtensionErrors = {
    /**
     * Extension not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveExtensionResponses = {
    /**
     * Extension removed successfully
     */
    200: string;
};

export type RemoveExtensionResponse = RemoveExtensionResponses[keyof RemoveExtensionResponses];

export type InitConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/init';
};

export type InitConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type InitConfigResponses = {
    /**
     * Config initialization check completed
     */
    200: string;
};

export type InitConfigResponse = InitConfigResponses[keyof InitConfigResponses];

export type UpsertPermissionsData = {
    body: UpsertPermissionsQuery;
    path?: never;
    query?: never;
    url: '/config/permissions';
};

export type UpsertPermissionsErrors = {
    /**
     * Invalid request
     */
    400: unknown;
};

export type UpsertPermissionsResponses = {
    /**
     * Permission update completed
     */
    200: string;
};

export type UpsertPermissionsResponse = UpsertPermissionsResponses[keyof UpsertPermissionsResponses];

export type ProvidersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/providers';
};

export type ProvidersResponses = {
    /**
     * All configuration values retrieved successfully
     */
    200: Array<ProviderDetails>;
};

export type ProvidersResponse2 = ProvidersResponses[keyof ProvidersResponses];

export type ReadConfigData = {
    body: ConfigKeyQuery;
    path?: never;
    query?: never;
    url: '/config/read';
};

export type ReadConfigErrors = {
    /**
     * Configuration key not found
     */
    404: unknown;
};

export type ReadConfigResponses = {
    /**
     * Configuration value retrieved successfully
     */
    200: unknown;
};

export type RecoverConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/recover';
};

export type RecoverConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type RecoverConfigResponses = {
    /**
     * Config recovery attempted
     */
    200: string;
};

export type RecoverConfigResponse = RecoverConfigResponses[keyof RecoverConfigResponses];

export type RemoveConfigData = {
    body: ConfigKeyQuery;
    path?: never;
    query?: never;
    url: '/config/remove';
};

export type RemoveConfigErrors = {
    /**
     * Configuration key not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type RemoveConfigResponses = {
    /**
     * Configuration value removed successfully
     */
    200: string;
};

export type RemoveConfigResponse = RemoveConfigResponses[keyof RemoveConfigResponses];

export type UpsertConfigData = {
    body: UpsertConfigQuery;
    path?: never;
    query?: never;
    url: '/config/upsert';
};

export type UpsertConfigErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpsertConfigResponses = {
    /**
     * Configuration value upserted successfully
     */
    200: string;
};

export type UpsertConfigResponse = UpsertConfigResponses[keyof UpsertConfigResponses];

export type ValidateConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config/validate';
};

export type ValidateConfigErrors = {
    /**
     * Config file is corrupted
     */
    422: unknown;
};

export type ValidateConfigResponses = {
    /**
     * Config validation result
     */
    200: string;
};

export type ValidateConfigResponse = ValidateConfigResponses[keyof ValidateConfigResponses];

export type ConfirmPermissionData = {
    body: PermissionConfirmationRequest;
    path?: never;
    query?: never;
    url: '/confirm';
};

export type ConfirmPermissionErrors = {
    /**
     * Unauthorized - invalid secret key
     */
    401: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ConfirmPermissionResponses = {
    /**
     * Permission action is confirmed
     */
    200: unknown;
};

export type ManageContextData = {
    body: ContextManageRequest;
    path?: never;
    query?: never;
    url: '/context/manage';
};

export type ManageContextErrors = {
    /**
     * Unauthorized - Invalid or missing API key
     */
    401: unknown;
    /**
     * Precondition failed - Agent not available
     */
    412: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ManageContextResponses = {
    /**
     * Context managed successfully
     */
    200: ContextManageResponse;
};

export type ManageContextResponse = ManageContextResponses[keyof ManageContextResponses];

export type CreateScheduleData = {
    body: CreateScheduleRequest;
    path?: never;
    query?: never;
    url: '/schedule/create';
};

export type CreateScheduleErrors = {
    /**
     * Invalid cron expression or recipe file
     */
    400: unknown;
    /**
     * Job ID already exists
     */
    409: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type CreateScheduleResponses = {
    /**
     * Scheduled job created successfully
     */
    200: ScheduledJob;
};

export type CreateScheduleResponse = CreateScheduleResponses[keyof CreateScheduleResponses];

export type DeleteScheduleData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to delete
         */
        id: string;
    };
    query?: never;
    url: '/schedule/delete/{id}';
};

export type DeleteScheduleErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type DeleteScheduleResponses = {
    /**
     * Scheduled job deleted successfully
     */
    204: void;
};

export type DeleteScheduleResponse = DeleteScheduleResponses[keyof DeleteScheduleResponses];

export type ListSchedulesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/schedule/list';
};

export type ListSchedulesErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListSchedulesResponses = {
    /**
     * A list of scheduled jobs
     */
    200: ListSchedulesResponse;
};

export type ListSchedulesResponse2 = ListSchedulesResponses[keyof ListSchedulesResponses];

export type UpdateScheduleData = {
    body: UpdateScheduleRequest;
    path: {
        /**
         * ID of the schedule to update
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}';
};

export type UpdateScheduleErrors = {
    /**
     * Cannot update a currently running job or invalid request
     */
    400: unknown;
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UpdateScheduleResponses = {
    /**
     * Scheduled job updated successfully
     */
    200: ScheduledJob;
};

export type UpdateScheduleResponse = UpdateScheduleResponses[keyof UpdateScheduleResponses];

export type InspectRunningJobData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to inspect
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/inspect';
};

export type InspectRunningJobErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type InspectRunningJobResponses = {
    /**
     * Running job information
     */
    200: InspectJobResponse;
};

export type InspectRunningJobResponse = InspectRunningJobResponses[keyof InspectRunningJobResponses];

export type KillRunningJobData = {
    body?: never;
    path: {
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/kill';
};

export type KillRunningJobResponses = {
    /**
     * Running job killed successfully
     */
    200: unknown;
};

export type PauseScheduleData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to pause
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/pause';
};

export type PauseScheduleErrors = {
    /**
     * Cannot pause a currently running job
     */
    400: unknown;
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type PauseScheduleResponses = {
    /**
     * Scheduled job paused successfully
     */
    204: void;
};

export type PauseScheduleResponse = PauseScheduleResponses[keyof PauseScheduleResponses];

export type RunNowHandlerData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to run
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/run_now';
};

export type RunNowHandlerErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error when trying to run the job
     */
    500: unknown;
};

export type RunNowHandlerResponses = {
    /**
     * Scheduled job triggered successfully, returns new session ID
     */
    200: RunNowResponse;
};

export type RunNowHandlerResponse = RunNowHandlerResponses[keyof RunNowHandlerResponses];

export type SessionsHandlerData = {
    body?: never;
    path: {
        /**
         * ID of the schedule
         */
        id: string;
    };
    query?: {
        limit?: number;
    };
    url: '/schedule/{id}/sessions';
};

export type SessionsHandlerErrors = {
    /**
     * Internal server error
     */
    500: unknown;
};

export type SessionsHandlerResponses = {
    /**
     * A list of session display info
     */
    200: Array<SessionDisplayInfo>;
};

export type SessionsHandlerResponse = SessionsHandlerResponses[keyof SessionsHandlerResponses];

export type UnpauseScheduleData = {
    body?: never;
    path: {
        /**
         * ID of the schedule to unpause
         */
        id: string;
    };
    query?: never;
    url: '/schedule/{id}/unpause';
};

export type UnpauseScheduleErrors = {
    /**
     * Scheduled job not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type UnpauseScheduleResponses = {
    /**
     * Scheduled job unpaused successfully
     */
    204: void;
};

export type UnpauseScheduleResponse = UnpauseScheduleResponses[keyof UnpauseScheduleResponses];

export type ListSessionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/sessions';
};

export type ListSessionsErrors = {
    /**
     * Unauthorized - Invalid or missing API key
     */
    401: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type ListSessionsResponses = {
    /**
     * List of available sessions retrieved successfully
     */
    200: SessionListResponse;
};

export type ListSessionsResponse = ListSessionsResponses[keyof ListSessionsResponses];

export type GetSessionHistoryData = {
    body?: never;
    path: {
        /**
         * Unique identifier for the session
         */
        session_id: string;
    };
    query?: never;
    url: '/sessions/{session_id}';
};

export type GetSessionHistoryErrors = {
    /**
     * Unauthorized - Invalid or missing API key
     */
    401: unknown;
    /**
     * Session not found
     */
    404: unknown;
    /**
     * Internal server error
     */
    500: unknown;
};

export type GetSessionHistoryResponses = {
    /**
     * Session history retrieved successfully
     */
    200: SessionHistoryResponse;
};

export type GetSessionHistoryResponse = GetSessionHistoryResponses[keyof GetSessionHistoryResponses];

export type ClientOptions = {
    baseUrl: `${string}://${string}` | (string & {});
};